rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ─────────────────────
    // Helper functions
    // ─────────────────────
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function getUserRole() {
      return isAuthenticated() 
        ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role
        : null;
    }
    
    function isAdmin() {
      return isAuthenticated() && getUserRole() == 'admin';
    }
    
    function isParkingOperator() {
      return isAuthenticated() &&
        (getUserRole() == 'parkingOperator' || getUserRole() == 'admin');
    }
    
    function isValidUser() {
      return isAuthenticated() &&
        (getUserRole() == 'user' ||
         getUserRole() == 'parkingOperator' ||
         getUserRole() == 'admin');
    }

    function isSpotOwner(spotId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/parkingSpots/$(spotId)).data.ownerId == request.auth.uid;
    }
    
    // ─────────────────────
    // Users collection
    // ─────────────────────
    match /users/{userId} {

      // Users can read, update, delete their own document
      allow read, update, delete: if isOwner(userId);
      
      // Allow user creation during registration
      // Users can create their own profile when they first sign in
      // This is critical for login flow - user document may not exist yet
      allow create: if isAuthenticated() &&
        request.auth.uid == userId &&
        request.resource.data.keys().hasAll(['email', 'displayName', 'role']) &&
        request.resource.data.role == 'user' &&
        // Ensure user can only set their own email
        request.resource.data.email is string &&
        request.resource.data.displayName is string;
      
      // Admins can read all users
      allow read: if isAdmin();
      
      // Parking operators can read basic user info (for bookings / verification)
      // NOTE: this only checks the doc has these fields; it cannot hide other fields.
      allow read: if isParkingOperator() && 
        resource.data.keys().hasAll(['id', 'displayName', 'email', 'phoneNumber']);
    }
    
    // ─────────────────────
    // Vehicles collection
    // ─────────────────────
    match /vehicles/{vehicleId} {

      // Users can read their own vehicles
      allow read: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;

      // Admins & parking operators can also read all vehicles
      allow read: if isAdmin() || isParkingOperator();
      
      // Allow creation if user owns the vehicle
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll([
          'userId', 'licensePlate', 'make', 'model', 'type', 'createdAt', 'updatedAt'
        ]);
      
      // Users can update/delete their own vehicles
      allow update, delete: if isAuthenticated() &&
        resource.data.userId == request.auth.uid;
      
      // Admins can manage all vehicles
      allow write: if isAdmin();
    }
    
    // ─────────────────────
    // Parking spots collection (parkingSpots)
    // ─────────────────────
    match /parkingSpots/{spotId} {
      // ALL authenticated users can read parking spots (for discovery)
      allow read: if isAuthenticated();
      
      // ONLY admins can create/update/delete parking spots
      allow create, update, delete: if isAdmin();
    }
    
    // ─────────────────────
    // Bookings collection (users book parking slots here)
    // ─────────────────────
    match /bookings/{bookingId} {

      function isBookingOwner() {
        return isAuthenticated() && resource.data.userId == request.auth.uid;
      }

      function isNewBookingOwner() {
        return isAuthenticated() && request.resource.data.userId == request.auth.uid;
      }

      // Helper function: validate booking status transitions
      function isValidStatusTransition(currentStatus, newStatus) {
        return
          // pending -> confirmed (user confirms booking)
          (currentStatus == 'pending' && newStatus == 'confirmed') ||
          // confirmed -> active (check-in)
          (currentStatus == 'confirmed' && newStatus == 'active') ||
          // active -> completed (check-out)
          (currentStatus == 'active' && newStatus == 'completed') ||
          // any status -> cancelled (cancellation)
          (newStatus == 'cancelled') ||
          // completed -> completed (no change allowed except cancellation)
          (currentStatus == 'completed' && newStatus == 'completed');
      }


      // READ: Allow reading for conflict checking and user's own bookings
      // Priority order matters - more specific rules first
      
      // Users can read their own bookings (highest priority)
      allow read: if isBookingOwner();

      // CRITICAL FIX: Allow reading bookings for conflict checking
      // When creating a booking, users need to query bookings by parkingSpotId
      // to check for time conflicts. This allows reading those bookings.
      // Note: This is necessary for the conflict check query in booking_provider.dart
      allow read: if isAuthenticated() &&
        resource.data.parkingSpotId != null &&
        resource.data.status in ['confirmed', 'active', 'pending'];

      // Parking operators can read bookings for their spots (for management)
      allow read: if isParkingOperator() &&
        isSpotOwner(resource.data.parkingSpotId);

      // Admins can read all bookings
      allow read: if isAdmin();

      // LIST/QUERY: Allow querying bookings for conflict checking
      // Users can query bookings by parkingSpotId to check availability
      // This allows: .where('parkingSpotId', isEqualTo: ...).where('status', whereIn: [...])
      // Require limit to prevent expensive queries (max 100 for conflict checking)
      allow list: if isAuthenticated() &&
        request.query.limit != null &&
        request.query.limit <= 100;

      // CREATE: Allow users to create bookings for themselves
      allow create: if isNewBookingOwner() &&
        // Required fields validation
        request.resource.data.keys().hasAll([
          'userId',
          'parkingSpotId',
          'vehicleId',
          'startTime',
          'endTime',
          'totalPrice',
          'status',
          'createdAt',
          'updatedAt'
        ]) &&
        // Status must be valid for new bookings
        request.resource.data.status in ['pending', 'confirmed'] &&
        // Basic time validation (start < end, both are timestamps)
        request.resource.data.startTime is timestamp &&
        request.resource.data.endTime is timestamp &&
        request.resource.data.startTime < request.resource.data.endTime &&
        // Price validation (must be positive)
        request.resource.data.totalPrice > 0 &&
        // Data consistency checks
        request.resource.data.userId == request.auth.uid;

      // UPDATE: Controlled status transitions and field updates
      allow update: if
        // User updating own booking (limited to cancellation and basic updates)
        (
          isBookingOwner() &&
          request.resource.data.userId == resource.data.userId &&
          (
            // Allow cancellation
            request.resource.data.status == 'cancelled' ||
            // Allow status progression: pending -> confirmed
            (resource.data.status == 'pending' && request.resource.data.status == 'confirmed') ||
            // Allow updating notes only (no status change)
            (request.resource.data.status == resource.data.status &&
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notes', 'updatedAt']))
          )
        )
        ||
        // Parking operator updating bookings for their spots (check-in/check-out)
        (
          isParkingOperator() &&
          isSpotOwner(resource.data.parkingSpotId) &&
          isValidStatusTransition(resource.data.status, request.resource.data.status) &&
          // Only allow status changes and timestamps
          request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'status', 'checkedInAt', 'checkedOutAt', 'updatedAt'
          ])
        )
        ||
        // Admin – full control with validation
        (
          isAdmin() &&
          isValidStatusTransition(resource.data.status, request.resource.data.status)
        );

      // DELETE: Only admins can delete bookings (for cleanup/archival)
      allow delete: if isAdmin();
    }
    
    // ─────────────────────
    // Reviews collection
    // ─────────────────────
    match /reviews/{reviewId} {
      // Valid users can read reviews
      allow read: if isValidUser();
      
      // Users can create reviews for their completed bookings
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasAll([
          'userId', 'parkingSpotId', 'bookingId', 'rating', 'createdAt'
        ]) &&
        request.resource.data.rating is number &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5;
      
      // Users can update/delete their own reviews
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Admins can manage all reviews
      allow write: if isAdmin();
    }
    
    // ─────────────────────
    // Notifications collection
    // ─────────────────────
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Users can update their own notifications (mark as read)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid &&
        request.resource.data.keys().hasOnly(['isRead', 'updatedAt']);
      
      // System/app can create notifications
      allow create: if isAuthenticated();
      
      // Admins can manage all notifications
      allow write: if isAdmin();
    }
    
    // ─────────────────────
    // Payment transactions collection
    // ─────────────────────
    match /transactions/{transactionId} {
      // Users can read their own transactions
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Parking operators can read transactions for their spots
      allow read: if isParkingOperator() && 
        isSpotOwner(resource.data.parkingSpotId);
      
      // System/app can create transactions for the user
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      
      // Admins can read/write all transactions
      allow read, write: if isAdmin();
    }
    
    // ─────────────────────
    // Analytics collection (admin only)
    // ─────────────────────
    match /analytics/{document=**} {
      allow read, write: if isAdmin();
    }
    
    // ─────────────────────
    // System configuration (config)
    // ─────────────────────
    match /config/{document=**} {
      // Valid users can read config
      allow read: if isValidUser();
      // Only admins can write config
      allow write: if isAdmin();
    }
    
    // ─────────────────────
    // Reports collection
    // ─────────────────────
    match /reports/{reportId} {
      // Users can create reports
      allow create: if isAuthenticated() && 
        request.resource.data.reportedBy == request.auth.uid;
      
      // Users can read their own reports
      allow read: if isAuthenticated() && resource.data.reportedBy == request.auth.uid;
      
      // Admins can manage all reports
      allow read, write: if isAdmin();
    }
    
    // ─────────────────────
    // SUPER ADMIN RULE
    // ─────────────────────
    // Admins can access ANY document in ANY collection (fallback)
    match /{document=**} {
      allow read, write: if isAdmin();
    }
  }
}
