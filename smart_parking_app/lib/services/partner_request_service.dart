// lib/services/partner_request_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../core/database/database_service.dart';
import '../models/partner_request.dart';
import '../models/user.dart';

class PartnerRequestService {
  static const String collectionName = 'partner_requests';

  /// Submit a partner request
  static Future<bool> submitPartnerRequest({
    required String userId,
    required String userEmail,
    required String userName,
    String? businessName,
    String? businessAddress,
    String? phoneNumber,
    String? reason,
  }) async {
    try {
      // Check if user already has a pending request
      final existingRequest = await _getPendingRequestByUserId(userId);
      if (existingRequest != null) {
        throw Exception('You already have a pending partner request');
      }

      // Check if user is already approved
      final userDoc = await DatabaseService.collection('users').doc(userId).get();
      if (userDoc.exists) {
        final userData = userDoc.data() as Map<String, dynamic>;
        if (userData['isPartnerApproved'] == true) {
          throw Exception('You are already an approved partner');
        }
      }

      // Create partner request
      final request = PartnerRequest(
        id: '', // Will be generated by Firestore
        userId: userId,
        userEmail: userEmail,
        userName: userName,
        businessName: businessName,
        businessAddress: businessAddress,
        phoneNumber: phoneNumber,
        reason: reason,
        status: PartnerRequestStatus.pending,
        createdAt: DateTime.now(),
      );

      // Save to Firestore
      await DatabaseService.collection(collectionName).add(request.toMap());

      // Update user's partner request status
      await DatabaseService.collection('users').doc(userId).update({
        'partnerRequestStatus': 'pending',
      });

      return true;
    } catch (e) {
      print('Error submitting partner request: $e');
      rethrow;
    }
  }

  /// Get partner request by user ID
  static Future<PartnerRequest?> getPartnerRequestByUserId(String userId) async {
    try {
      final query = await DatabaseService.collection(collectionName)
          .where('userId', isEqualTo: userId)
          .orderBy('createdAt', descending: true)
          .limit(1)
          .get();

      if (query.docs.isEmpty) {
        return null;
      }

      return PartnerRequest.fromFirestore(query.docs.first);
    } catch (e) {
      print('Error getting partner request: $e');
      return null;
    }
  }

  /// Get pending partner request by user ID
  static Future<PartnerRequest?> _getPendingRequestByUserId(String userId) async {
    try {
      final query = await DatabaseService.collection(collectionName)
          .where('userId', isEqualTo: userId)
          .where('status', isEqualTo: 'pending')
          .limit(1)
          .get();

      if (query.docs.isEmpty) {
        return null;
      }

      return PartnerRequest.fromFirestore(query.docs.first);
    } catch (e) {
      print('Error getting pending partner request: $e');
      return null;
    }
  }

  /// Check if user can add parking spots (must be approved partner)
  static Future<bool> canAddParkingSpots(String userId) async {
    try {
      final userDoc = await DatabaseService.collection('users').doc(userId).get();
      if (!userDoc.exists) {
        return false;
      }

      final userData = userDoc.data() as Map<String, dynamic>;
      final role = userData['role'] as String?;
      final isPartnerApproved = userData['isPartnerApproved'] ?? false;

      // User must be parkingOperator role AND approved as partner
      return role == 'parkingOperator' && isPartnerApproved;
    } catch (e) {
      print('Error checking if user can add parking spots: $e');
      return false;
    }
  }
}
